# Лекція 1

# Багатопотокове програмування

## 1. Модель потоків Java

Система виконання Java залежить від потоків для багатьох завдань, і всі бібліотеки класів спроектовані з урахуванням багатопоточності. Насправді, Java використовує потоки, щоб забезпечити асинхронність середовища. Це допомагає зменшити неефективність, запобігаючи марнуванням циклів процесора.

Цінність багатопотокового середовища найкраще зрозуміла в контексті його протилежності. Системи з одним потоком використовують підхід, званий циклом подій з опитуванням. У цій моделі один потік контролю виконує нескінченний цикл, опитуючи одну чергу подій, щоб вирішити, що робити далі. Як тільки цей механізм опитування повертає сигнал, наприклад, що мережева частина файлу готова для читання, цикл подій передає контроль відповідному обробнику подій.

Поки цей обробник не завершить свою роботу, в програмі нічого більше не відбувається. Це марнує час процесора і може призвести до того, що одна частина програми домінує в системі, перешкоджаючи обробці інших подій. Загалом, в однопоточному середовищі, коли потік блокується (тобто призупиняє виконання) через те, що чекає ресурсу, вся програма перестає виконуватись.

Перевага багатопоточності в Java полягає в тому, що основний цикл/механізм опитування усувається. Один потік може призупинитися, не зупиняючи інші частини вашої програми. Наприклад, час простоювання, коли потік читає дані з мережі або чекає на введення від користувача, може бути використаний в інших частинах програми. Багатопоточність дозволяє анімаційним циклам спати секунду між кожним кадром, не призупиняючи всю систему. Коли потік блокується в програмі Java, тільки цей конкретний потік призупиняється. Інші потоки продовжують виконання.

Як відомо більшості читачів, останні кілька років багатоядерні системи стали звичайним явищем. Звичайно, однопоточні системи все ще широко використовуються. Важливо розуміти, що функції багатопоточності Java працюють в обох типах систем. У однопоточній системі одночасно виконувані потоки ділять процесор, причому кожен потік отримує частку часу процесора. Тому в однопоточній системі два або більше потоки фактично не виконуються одночасно, але час простоювання процесора використовується. Однак у багатоядерних системах два або більше потоки можуть фактично виконуватися одночасно. У багатьох випадках це може ще більше покращити ефективність програми та збільшити швидкість певних операцій.

Потоки існують у кількох станах. Ось загальний опис:
- **Виконання**: Потік може бути в стані виконання.
- **Готовий** до виконання: Потік може бути готовим до виконання, як тільки отримає час процесора.
- **Призупинений**: Виконуючийся потік може бути призупинений, що тимчасово зупиняє його діяльність. Призупинений потік можна відновити, що дозволяє йому продовжити виконання з того місця, де він зупинився.
- **Блокований**: Потік може бути заблокованим, коли чекає на ресурс.
- **Припинений**: У будь-який момент потік може бути завершений, що миттєво припиняє його виконання. Після завершення потік не може бути відновлений.

### Пріоритети потоків 

Java призначає кожному потоку пріоритет, який визначає, як цей потік слід обробляти в порівнянні з іншими. Пріоритети потоків є цілими числами, які вказують відносний пріоритет одного потоку відносно іншого. Як абсолютне значення, пріоритет не має сенсу; потік з вищим пріоритетом не буде виконуватися швидше за потік з нижчим пріоритетом, якщо це єдиний виконуваний потік. Замість цього, пріоритет потоку використовується для визначення моменту переключення з одного виконуваного потоку на інший. Це називається переключенням контексту. Правила, що визначають, коли відбувається переключення контексту, є простими:

- Потік може добровільно відмовитися від контролю. Це відбувається при явному звільненні, сні або блокуванні. У цьому випадку всі інші потоки перевіряються, і потоку з найвищим пріоритетом, який готовий до виконання, надається процесор.
- Потік може бути перерваний потоком з вищим пріоритетом. У цьому випадку потік з нижчим пріоритетом, який не звільняє процесор, просто переривається — незалежно від того, що він робить — потоком з вищим пріоритетом. Основна ідея полягає в тому, що, як тільки потік з вищим пріоритетом хоче виконуватися, він це робить. Це називається передаючим багатозадачним режимом.

У випадках, коли два потоки з однаковим пріоритетом змагаються за час процесора, ситуація дещо ускладнюється. Для деяких операційних систем потоки з однаковим пріоритетом автоматично розподіляються по черзі за круговою схемою. Для інших типів операційних систем потоки з однаковим пріоритетом повинні добровільно відмовитися від контролю на користь своїх колег. Якщо вони цього не зроблять, інші потоки не будуть виконуватися.

### Синхронізація

Оскільки багатопоточність вводить асинхронну поведінку у ваші програми, має бути спосіб забезпечити синхронність, коли це необхідно. Наприклад, якщо ви хочете, щоб два потоки спілкувалися та ділилися складною структурою даних, такою як зв'язний список, вам потрібно забезпечити, щоб вони не конфліктували один з одним. Тобто, необхідно запобігти ситуації, коли один потік записує дані, поки інший потік їх читає. Для цього Java реалізує елегантний варіант стародавньої моделі міжпроцесної синхронізації: монітор.

Монітор — це механізм контролю, вперше визначений C.A.R. Hoare. Ви можете уявити монітор як дуже маленьку коробку, яка може вміщати лише один потік. Як тільки потік входить у монітор, всі інші потоки повинні чекати, поки цей потік не вийде з монітора. Таким чином, монітор може бути використаний для захисту спільного ресурсу від маніпуляцій з боку більше ніж одного потоку одночасно.

У Java немає класу "Monitor"; натомість кожен об'єкт має свій власний неявний монітор, до якого автоматично входять, коли викликається один з синхронізованих методів об'єкта. Як тільки потік знаходиться всередині синхронізованого методу, жоден інший потік не може викликати інший синхронізований метод на тому ж об'єкті. Це дозволяє писати дуже чіткий і зрозумілий багатопотоковий код, оскільки підтримка синхронізації вбудована в мову.

### Обмін повідомленнями

Після того, як ви розділите вашу програму на окремі потоки, потрібно визначити, як вони будуть спілкуватися один з одним. У програмуванні з деякими іншими мовами ви повинні покладатися на операційну систему для встановлення зв'язку між потоками, що, звичайно, додає накладні витрати. На відміну від цього, Java надає чистий і низьковартісний спосіб для двох або більше потоків спілкуватися між собою через виклики заздалегідь визначених методів, які мають усі об'єкти. Система обміну повідомленнями в Java дозволяє потоку увійти до синхронізованого методу об'єкта, а потім чекати там, поки інший потік явно не сповістить його про необхідність вийти.

### Клас Thread і інтерфейс Runnable

Багатопотокова система Java побудована на класі Thread, його методах та супутньому інтерфейсі Runnable. Клас Thread інкапсулює потік виконання. Оскільки ви не можете безпосередньо звертатися до ефемерного стану виконуючогося потоку, ви працюєте з ним через його проксі — екземпляр класу Thread, який його створив. Щоб створити новий потік, ваша програма або розширює клас Thread, або реалізує інтерфейс Runnable.

Клас Thread визначає кілька методів, які допомагають керувати потоками. Декілька з них, які використовуються в цьому розділі, наведені нижче:

![img.png](https://www.wwwjavalearnapp.store/img/2024_3_course_cpp_lecture_1_img_1.png)

До цього моменту всі приклади в книзі використовували один потік виконання. Решта розділу пояснює, як використовувати Thread і Runnable для створення та управління потоками, починаючи з того потоку, який має кожна Java-програма: основного потоку.

## 2. Головний потік

Коли Java-програма запускається, відразу починає виконання один потік. Його зазвичай називають основним потоком програми, оскільки саме цей потік виконується при старті програми. Основний потік важливий з двох причин:

- Це той потік, з якого будуть створюватися інші "дочірні" потоки.
- Часто він має бути останнім, що завершує виконання, оскільки виконує різні дії по завершенню роботи.

Хоча основний потік створюється автоматично при запуску програми, ним можна керувати через об'єкт Thread. Для цього потрібно отримати посилання на нього, викликавши метод `currentThread()`, який є публічним статичним членом класу Thread. Його загальний вигляд:

```java
static Thread currentThread()
```

Цей метод повертає посилання на потік, в якому він був викликаний. Як тільки ви отримали посилання на основний потік, ви можете керувати ним так само, як і будь-яким іншим потоком.

Давайте розглянемо наступний приклад:

```java
// Controlling the main Thread.
class CurrentThreadDemo {
    public static void main(String[] args) {
        Thread t = Thread.currentThread();
        System.out.println("Current thread: " + t);
        // change the name of the thread
        t.setName("My Thread");
        System.out.println("After name change: " + t);
        try {
            for(int n = 5; n > 0; n--) {
                System.out.println(n);
                Thread.sleep(1000);
            }
        } catch (InterruptedException e) {
            System.out.println("Main thread interrupted");
        }
    }
}
```


У цій програмі посилання на поточний потік (в цьому випадку, основний потік) отримується за допомогою виклику `currentThread()`, і це посилання зберігається в локальній змінній `t`. Далі програма відображає інформацію про потік. Потім програма викликає метод `setName()` для зміни внутрішньої назви потоку. Інформація про потік відображається знову.

Далі цикл зменшує лічильник від п'яти, роблячи паузу на одну секунду між кожним рядком. Пауза досягається за допомогою методу `sleep()`. Аргумент методу `sleep()` вказує період затримки в мілісекундах. Зверніть увагу на блок `try/catch` навколо цього циклу. Метод `sleep()` у класі Thread може викидати виключення `InterruptedException`, якщо якийсь інший потік захоче перервати цей сплячий потік. У цьому прикладі просто виводиться повідомлення, якщо виникає переривання. У реальній програмі вам потрібно буде обробляти це по-іншому.

Ось виведення, яке генерує ця програма:

```text
Current thread: Thread[main,5,main]
After name change: Thread[My Thread,5,main]
5
4
3
2
1
```

Зверніть увагу на виведення, яке отримується, коли `t` використовується як аргумент для `println()`. Це виводить, у порядку: назву потоку, його пріоритет і назву його групи. За замовчуванням назва основного потоку — `main`. Його пріоритет — 5, що є значенням за замовчуванням, а `main` також є назвою групи потоків, до якої належить цей потік. Група потоків — це структура даних, яка контролює стан колекції потоків загалом. Після зміни назви потоку, `t` знову виводиться. Цього разу відображається нове ім'я потоку.

Розглянемо більш детально методи, визначені у класі Thread, які використовуються в програмі. Метод `sleep()` призупиняє виконання потоку, з якого він був викликаний, на зазначений період у мілісекундах. Його загальна форма:

```java
static void sleep(long milliseconds) throws InterruptedException
```

Час, на який потрібно призупинити виконання, вказується в мілісекундах. Метод `sleep()` може викидати виключення `InterruptedException`.
Метод `sleep()` має другу форму, яка дозволяє вказати період у мілісекундах і наносекундах:

```java
static void sleep(long milliseconds, int nanoseconds) throws InterruptedException
```

Ця друга форма корисна лише в середовищах, які дозволяють задавати періоди часу так коротко, як наносекунди.

Як показано в попередній програмі, ви можете встановити назву потоку, використовуючи `setName()`. Ви можете отримати назву потоку, викликавши `getName()` (але це не показано в програмі). Ці методи є членами класу Thread і оголошені так:

```java
final void setName(String threadName)
final String getName()
```

Тут `threadName` вказує на назву потоку.

## 3. Створення потоку

У найзагальнішому вигляді, ви створюєте потік, створюючи об'єкт типу Thread. Java визначає два способи, як це можна реалізувати:

- Ви можете реалізувати інтерфейс Runnable.
- Ви можете розширити клас Thread.

У наступних розділах розглядаються кожен з цих методів окремо.

### Реалізація Runnable

Найпростіший спосіб створити потік — це створити клас, який реалізує інтерфейс `Runnable`. `Runnable` абстрагує одиницю виконуваного коду. Ви можете створити потік на основі будь-якого об'єкта, що реалізує `Runnable`. Щоб реалізувати `Runnable`, класу потрібно реалізувати лише один метод, названий `run()`, який оголошений наступним чином:

```java
public void run()
```

Всередині `run()` ви визначите код, який буде складати новий потік. Важливо розуміти, що `run()` може викликати інші методи, використовувати інші класи та оголошувати змінні, так само як і основний потік.

Єдина різниця в тому, що `run()` встановлює точку входу для іншого, паралельного потоку виконання у вашій програмі. Цей потік закінчиться, коли `run()` поверне результат.

Після створення класу, який реалізує `Runnable`, ви створите об'єкт типу `Thread` зсередини цього класу. `Thread` визначає кілька конструкторів. Той, який ми будемо використовувати, показаний нижче:

```java
Thread(Runnable threadOb, String threadName)
```

У цьому конструкторі, `threadOb` є екземпляром класу, який реалізує інтерфейс `Runnable`. Це визначає, з чого почнеться виконання потоку. Назва нового потоку вказується за допомогою `threadName`.

Після створення нового потоку він не почне виконання, поки ви не викличете його метод `start()`, який оголошений у класі `Thread`. По суті, `start()` ініціює виклик `run()`. Метод `start()` виглядає так:

```java
void start()
```

Ось приклад, який створює новий потік і запускає його:

```java
// Create a second thread.
class NewThread implements Runnable {
    Thread t;
    NewThread() {
        // Create a new, second thread
        t = new Thread(this, "Demo Thread");
        System.out.println("Child thread: " + t);
    }
    // This is the entry point for the second thread.
    public void run() {
        try {
            for(int i = 5; i > 0; i--) {
                System.out.println("Child Thread: " + i);
                Thread.sleep(500);
            }
        } catch (InterruptedException e) {
            System.out.println("Child interrupted.");
        }
        System.out.println("Exiting child thread.");
    }
}

class ThreadDemo {
    public static void main(String[] args) {
        NewThread nt = new NewThread(); // create a new thread
        nt.t.start(); // Start the thread
        try {
            for(int i = 5; i > 0; i--) {
                System.out.println("Main Thread: " + i);
                Thread.sleep(1000);
            }
        } catch (InterruptedException e) {
            System.out.println("Main thread interrupted.");
        }
        System.out.println("Main thread exiting.");
    }
}
```

Всередині конструктора `NewThread` новий об'єкт `Thread` створюється за допомогою наступного виразу:

```java
t = new Thread(this, "Demo Thread");
```
Передача `this` як першого аргументу вказує, що ви хочете, щоб новий потік викликав метод `run()` для цього об'єкта. Усередині `main()`, викликається метод `start()`, який запускає потік виконання, починаючи з методу `run()`. Це призводить до початку виконання циклу `for` дочірнього потоку. Наступним кроком основний потік входить у свій цикл `for`. Обидва потоки продовжують виконання, розподіляючи ресурси процесора в однопроцесорних системах, поки їх цикли не закінчаться. Виведення, яке створює ця програма, виглядає наступним чином. (Ваше виведення може відрізнятися залежно від конкретного середовища виконання.)

```text
Child thread: Thread[Demo Thread,5,main]
Main Thread: 5
Child Thread: 5
Child Thread: 4
Main Thread: 4
Child Thread: 3
Child Thread: 2
Main Thread: 3
Child Thread: 1
Exiting child thread.
Main Thread: 2
Main Thread: 1
Main thread exiting.
```

Як згадувалося раніше, у багатопотоковій програмі часто корисно, щоб основний потік був останнім, що завершить виконання. У попередній програмі це забезпечується тим, що основний потік спить 1,000 мілісекунд між ітераціями, тоді як дочірній потік спить лише 500 мілісекунд. Це призводить до того, що дочірній потік завершує свою роботу раніше, ніж основний потік. Незабаром ви побачите кращий спосіб дочекатися завершення потоку.

### Розширення класу Thread

Другий спосіб створення потоку — це створення нового класу, який розширює клас `Thread`, і потім створення екземпляра цього класу. Розширюючий клас повинен перевизначити метод `run()`, який є точкою входу для нового потоку. Як і раніше, виклик `start()` розпочинає виконання нового потоку. Ось попередня програма, переписана для розширення класу `Thread`:

```java
// Create a second thread by extending Thread
class NewThread extends Thread {
    NewThread() {
// Create a new, second thread
        super("Demo Thread");
        System.out.println("Child thread: " + this);
    }
    // This is the entry point for the second thread.
    public void run() {
        try {
            for(int i = 5; i > 0; i--) {
                System.out.println("Child Thread: " + i);
                Thread.sleep(500);
            }
        } catch (InterruptedException e) {
            System.out.println("Child interrupted.");
        }
        System.out.println("Exiting child thread.");
    }
}

class ExtendThread {
    public static void main(String[] args) {
        NewThread nt = new NewThread(); // create a new thread
        nt.start(); // start the thread
        try {
            for(int i = 5; i > 0; i--) {
                System.out.println("Main Thread: " + i);
                Thread.sleep(1000);
            }
        } catch (InterruptedException e) {
            System.out.println("Main thread interrupted.");
        }
        System.out.println("Main thread exiting.");
    }
}
```

Ця програма генерує таке ж виведення, як і попередня версія. Як ви бачите, дочірній потік створюється шляхом створення об'єкта класу `NewThread`, який походить від `Thread`.

Зверніть увагу на виклик `super()` всередині `NewThread`. Це викликає таку форму конструктора класу `Thread`:

```java
public Thread(String threadName)
```

Тут `threadName` вказує на назву потоку.

### Вибір підходу

На цьому етапі ви можете запитуватися, чому Java має два способи створення дочірніх потоків і який підхід краще. Відповіді на ці питання зводяться до одного й того ж аспекту. Клас `Thread` визначає кілька методів, які можна перевизначити в похідному класі. З цих методів єдиний, який потрібно перевизначити, — це `run()`. Це, звичайно, той же метод, який потрібен при реалізації `Runnable`.

Багато програмістів Java вважають, що класи слід розширювати лише тоді, коли їх потрібно вдосконалити або адаптувати певним чином. Тому, якщо ви не будете перевизначати жоден з інших методів класу `Thread`, краще реалізувати `Runnable`. Також, реалізуючи `Runnable`, ваш клас потоку не потребує успадкування від `Thread`, що дозволяє йому успадковувати інший клас.

В кінцевому рахунку, який підхід використовувати, залежить від вас.




