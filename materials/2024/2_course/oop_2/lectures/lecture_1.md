# Лекція 1

# Шаблон Interface

## 1. Опис шаблону Interface

Загалом, функціональність об'єктно-орієнтованої системи укладена у вигляді набору об'єктів. Ці об'єкти надають різні
послуги або самостійно, або взаємодіючи з іншими об'єктами. Іншими словами, даному об'єкту може знадобитися скористатися
послугами іншого об'єкта, щоб виконати ту службу, для якої він призначений. Об'єкт, який запитує послугу в іншого
об'єкта, називається клієнтським об'єктом. Деякі інші об'єкти в системі можуть шукати послуги, які надає клієнтський
об'єкт.

![img.png](https://www.wwwjavalearnapp.store/img/2024_2_course_oop_2_lecture_1_img_1.png)

Рис.1 - Взаємодія клієнт – постачальник послуг

З рис. 1 випливає, що клієнтський об'єкт припускає, що об'єкти постачальників послуг, що відповідають конкретному запиту
на послугу, завжди належать до одного й того ж типу класу і взаємодіє безпосередньо з об'єктом постачальника послуг. Цей
тип прямої взаємодії пов'язує клієнта з конкретним типом класу для певного запиту на послугу. Цей підхід добре працює,
коли існує лише один клас об'єктів, який пропонує певну послугу, але може бути недостатнім, коли існує більше одного
класу об'єктів, які надають ту ж саму послугу, яку потребує клієнт (рис. 2).

![img.png](https://www.wwwjavalearnapp.store/img/2024_2_course_oop_2_lecture_1_img_2.png)

Рис. 2 - Різні класи постачальників послуг, що пропонують однаковий набір послуг

Тому що клієнт очікує, що постачальник послуг завжди буде одного й того ж типу класу, він не зможе використовувати різні
класи об'єктів постачальників послуг безперешкодно. Це вимагає змін у дизайні та реалізації клієнта та значно обмежує
можливість використання клієнтом іншими об'єктами.

У таких випадках можна використовувати шаблон Інтерфейсу для кращого проектування різних класів постачальників послуг,
які пропонують однакові послуги, щоб дозволити клієнтському об'єкту використовувати різні класи об'єктів постачальників
послуг з мінімальними чи без потреби в зміні коду клієнта. Застосовуючи шаблон Інтерфейсу, загальні послуги, які
надаються різними класами постачальників послуг, можуть бути виокремлені та визначені як окремий інтерфейс. Кожен з
класів постачальників послуг може бути розроблений як реалізатор цього загального інтерфейсу.

![img.png](https://www.wwwjavalearnapp.store/img/2024_2_course_oop_2_lecture_1_img_3.png)

Рис. 3 - Спільний інтерфейс із різними постачальниками служб як імплементаторами

З цим узгодженням клієнт може безпечно вважати об'єкт постачальника послуг типу інтерфейсу. Зі структури класів на рис.
3 об'єкти різних класів постачальників послуг можуть бути розглянуті як об'єкти типу інтерфейсу. Це дозволяє клієнту
використовувати об'єкти різних типів постачальників послуг легко, без необхідності внесення змін. Клієнту не потрібно
буде вносити зміни навіть тоді, коли новий постачальник послуг проектується як частина ієрархії класів на рис. 3.

З таким устроєм, клієнт може безпечно припускати, що об'єкт постачальника послуг є типом інтерфейсу. З ієрархії класів
на рис. 3 об'єкти різних класів постачальників послуг можна розглядати як об'єкти типу інтерфейсу. Це дозволяє клієнту
використовувати різні типи об'єктів постачальників послуг безперешкодно, без необхідності будь-яких змін. Клієнт не
потребує модифікацій навіть тоді, коли новий постачальник послуг розробляється як частина ієрархії класів на рис. 3.

## 2. Приклад

Давайте створимо додаток для розрахунку та відображення зарплат різних працівників організації з категоризацією за
посадами.

Давайте припустимо, що додаток повинен враховувати лише тих працівників, чиї посади входять до категорії А. Функціонал
розрахунку заробітної плати для всіх працівників категорії А може бути розроблений у вигляді класу "CategoryA" наступним
чином:

Табл. 1 - Різні категорії посад

![img.png](https://www.wwwjavalearnapp.store/img/2024_2_course_oop_2_lecture_1_img_4.png)

```java
public class CategoryA {
    double baseSalary;
    double OT;

    public CategoryA(double base, double overTime) {
        baseSalary = base;
        OT = overTime;
    }

    public double getSalary() {
        return (baseSalary + OT);
    }
}
```

Представлення класу працівника в його найпростішій формі може бути розроблене, як показано в наступному лістингу з двома
атрибутами: ім'ям працівника та категорією посади.

```java
public class Employee {

    CategoryA salaryCalculator;
    String name;

    public Employee(String s, CategoryA c) {
        name = s;
        salaryCalculator = c;
    }

    public void display() {
        System.out.println("Name=" + name);
        System.out.println("salary= " + salaryCalculator.getSalary());
    }
}
```

Об'єкт клієнта може налаштовувати об'єкт Employee, передаючи значення для атрибутів ім'я та категорія при виклику його
конструктора. Після цього об'єкт клієнта може викликати метод display для відображення деталей імені та зарплати
працівника. Оскільки ми маємо справу лише з працівниками, які належать до Категорії-А, екземпляри класу Employee завжди
очікують, що тип категорії і, отже, калькулятор зарплати завжди буде типу CategoryA. У своїй реалізації методу display
клас Employee використовує сервіс розрахунку зарплати, наданий класом CategoryA.

Об'єкт головного додатку MainApp, який повинен відображати деталі зарплати працівників, виконує наступні завдання:

1. Створює екземпляр класу CategoryA, передаючи необхідні деталі для розрахунку зарплати.
2. Створює об'єкт Employee і налаштовує його з об'єктом CategoryA, створеним вище.
3. Викликає метод display на об'єкті Employee.
4. Об'єкт Employee використовує сервіси об'єкта CategoryA при розрахунку зарплати працівника, якого він представляє. У
   цьому випадку об'єкт Employee виступає як клієнт об'єкта CategoryA.

```java
public class MainApp {
    public static void main(String[] args) {
        CategoryA c = new CategoryA(10000, 200);
        Employee e = new Employee("Jennifer", c);
        e.display();
    }
}
```

Цей дизайн працює добре, коли потрібно обчислити зарплату лише для працівників категорії-А, і існує лише один клас
об'єктів, який забезпечує цю послугу. Але той факт, що об'єкт Employee очікує, що об'єкт постачальника послуг з
розрахунку зарплати завжди буде типу CategoryA, впливає на збереженість та призводить до обмеження гнучкості дизайну
програми.

Давайте припустимо, що додаток також повинен розраховувати зарплату для працівників, які входять до категорії-Б, таких
як представники збуту та представники обліку, і відповідна послуга розрахунку зарплати надається об'єктами іншого класу
CategoryB.

```java
public class CategoryB {

}
    double salesAmt;
    double baseSalary;

    final static double commission = 0.02;

    public CategoryB(double sa, double base) {
        baseSalary = base;
        salesAmt = sa;
    }

    public double getSalary() {
        return (baseSalary + (commission * salesAmt));
    }
}
```

![img.png](https://www.wwwjavalearnapp.store/img/2024_2_course_oop_2_lecture_1_img_5.png)

Рис. 4 - Асоціація класів Employee/Consultant/Salesrep

Головний об'єкт додатка MainApp зможе створити екземпляр класу CategoryB, але не зможе налаштувати об'єкт Employee з цим
екземпляром. Це тому, що об'єкт Employee очікує, що калькулятор зарплати завжди буде типу CategoryA. У результаті
головний додаток не зможе використовувати існуючий клас Employee для представлення різних типів працівників (рис. 4).
Існуюча реалізація класу Employee повинна пройти необхідні модифікації для прийняття додаткових типів постачальників
послуг калькулятора зарплати. Ці обмеження можна вирішити, використовуючи шаблон Інтерфейсу, що призведе до набагато
більш гнучкого дизайну додатка.

Застосовуючи шаблон Інтерфейсу, можна внести такі три зміни до дизайну додатка.

1. Загальний сервіс розрахунку зарплати, який надають різні об'єкти, може бути абстрагований до окремого інтерфейсу
   SalaryCalculator.

```java
public interface SalaryCalculator {

    public double getSalary();
}
```

2. Кожен з класів CategoryA та CategoryB може бути розроблений як реалізатор інтерфейсу SalaryCalculator (рис. 5).

```java
public class CategoryA implements SalaryCalculator {
    double baseSalary;
    double OT;

    public CategoryA(double base, double overTime) {
        baseSalary = base;
        OT = overTime;
    }

    public double getSalary() {
        return (baseSalary + OT);
    }
}

public class CategoryB implements SalaryCalculator {
    double salesAmt;
    double baseSalary;
    final static double commission = 0.02;

    public CategoryB(double sa, double base) {
        baseSalary = base;
        salesAmt = sa;
    }

    public double getSalary() {
        return (baseSalary + (commission * salesAmt));
    }
}
```

![img.png](https://www.wwwjavalearnapp.store/img/2024_2_course_oop_2_lecture_1_img_6.png)

Рис. 5 - Ієрархія класів постачальників послуг розрахунку зарплати

3. Реалізацію класу Employee потрібно змінити для прийняття постачальника послуг розрахунку зарплати типу
   SalaryCalculator.

```java
public class Employee {
    SalaryCalculator empType;
    String name;

    public Employee(String s, SalaryCalculator c) {
        name = s;
        empType = c;
    }

    public void display() {
        System.out.println("Name=" + name);
        System.out.println("salary= " + empType.getSalary());
    }
}
```

З внесеними цими змінами головний об'єкт додатка MainApp тепер може створювати об'єкти різних класів калькуляторів
зарплати та використовувати їх для конфігурації різних об'єктів Employee. Оскільки клас Employee, в оновленому дизайні,
приймає об'єкти типу SalaryCalculator, його можна налаштовувати екземпляром будь-якого класу, який реалізує інтерфейс
SalaryCalculator (чи його підклас). На рис. 6 показано асоціацію об'єктів додатка.

```java
public class MainApp {

    public static void main(String[] args) {
        SalaryCalculator c = new CategoryA(10000, 200);
        Employee e = new Employee("Jennifer", c);
        e.display();
        c = new CategoryB(20000, 800);
        e = new Employee("Shania", c);
        e.display();
    }
}
```

![img.png](https://www.wwwjavalearnapp.store/img/2024_2_course_oop_2_lecture_1_img_7.png)

Рис. 6 - Приклад асоціації додатка/класу
